import Gaffer
import GafferImage
import GafferOSL
import GafferScene
import IECore
import imath

Gaffer.Metadata.registerValue( parent, "serialiser:milestoneVersion", 1, persistent=False )
Gaffer.Metadata.registerValue( parent, "serialiser:majorVersion", 6, persistent=False )
Gaffer.Metadata.registerValue( parent, "serialiser:minorVersion", 0, persistent=False )
Gaffer.Metadata.registerValue( parent, "serialiser:patchVersion", 0, persistent=False )

__children = {}

parent["variables"].addChild( Gaffer.NameValuePlug( "image:catalogue:port", Gaffer.IntPlug( "value", defaultValue = 0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ), "imageCataloguePort", Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic ) )
parent["variables"].addChild( Gaffer.NameValuePlug( "project:name", Gaffer.StringPlug( "value", defaultValue = 'default', flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ), "projectName", Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic ) )
parent["variables"].addChild( Gaffer.NameValuePlug( "project:rootDirectory", Gaffer.StringPlug( "value", defaultValue = '$HOME/gaffer/projects/${project:name}', flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ), "projectRootDirectory", Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic ) )
parent["variables"].addChild( Gaffer.NameValuePlug( "renderPass", Gaffer.StringPlug( "value", defaultValue = '', ), "renderPass", Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic ) )
__children["openColorIO"] = GafferImage.OpenColorIOConfigPlug( "openColorIO", flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, )
parent.addChild( __children["openColorIO"] )
__children["defaultFormat"] = GafferImage.FormatPlug( "defaultFormat", defaultValue = GafferImage.Format( 1920, 1080, 1.000 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, )
parent.addChild( __children["defaultFormat"] )
__children["Sphere"] = GafferScene.Sphere( "Sphere" )
parent.addChild( __children["Sphere"] )
__children["Sphere"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Scatter"] = GafferScene.Scatter( "Scatter" )
parent.addChild( __children["Scatter"] )
__children["Scatter"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["PlanetPathFilter"] = GafferScene.PathFilter( "PlanetPathFilter" )
parent.addChild( __children["PlanetPathFilter"] )
__children["PlanetPathFilter"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["RobotInstancer"] = GafferScene.Instancer( "RobotInstancer" )
parent.addChild( __children["RobotInstancer"] )
__children["RobotInstancer"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["RobotSceneReader"] = GafferScene.SceneReader( "RobotSceneReader" )
parent.addChild( __children["RobotSceneReader"] )
__children["RobotSceneReader"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["RobotOrientation"] = GafferScene.Orientation( "RobotOrientation" )
parent.addChild( __children["RobotOrientation"] )
__children["RobotOrientation"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["RobotPathFilter"] = GafferScene.PathFilter( "RobotPathFilter" )
parent.addChild( __children["RobotPathFilter"] )
__children["RobotPathFilter"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["OSLObject"] = GafferOSL.OSLObject( "OSLObject" )
parent.addChild( __children["OSLObject"] )
__children["OSLObject"]["sourceLocations"].resize( 1 )
__children["OSLObject"]["primitiveVariables"].addChild( Gaffer.NameValuePlug( "customFloat", Gaffer.FloatPlug( "value", defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ), True, "primitiveVariable", Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic ) )
__children["OSLObject"]["primitiveVariables"].addChild( Gaffer.NameValuePlug( "customVector", Gaffer.V3fPlug( "value", defaultValue = imath.V3f( 0, 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, interpretation = IECore.GeometricData.Interpretation.Vector ), True, "primitiveVariable1", Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic ) )
__children["OSLObject"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["OSLCode"] = GafferOSL.OSLCode( "OSLCode" )
parent.addChild( __children["OSLCode"] )
__children["OSLCode"]["parameters"].addChild( Gaffer.FloatPlug( "searchRadius", defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["OSLCode"]["out"].addChild( Gaffer.FloatPlug( "cowDensity", direction = Gaffer.Plug.Direction.Out, defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["OSLCode"]["out"].addChild( Gaffer.V3fPlug( "cowFacingDirection", direction = Gaffer.Plug.Direction.Out, defaultValue = imath.V3f( 0, 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, interpretation = IECore.GeometricData.Interpretation.Vector ) )
__children["OSLCode"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["CowScatter"] = GafferScene.Scatter( "CowScatter" )
parent.addChild( __children["CowScatter"] )
__children["CowScatter"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["CowSceneReader"] = GafferScene.SceneReader( "CowSceneReader" )
parent.addChild( __children["CowSceneReader"] )
__children["CowSceneReader"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["CowInstancer"] = GafferScene.Instancer( "CowInstancer" )
parent.addChild( __children["CowInstancer"] )
__children["CowInstancer"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["CowPathFilter"] = GafferScene.PathFilter( "CowPathFilter" )
parent.addChild( __children["CowPathFilter"] )
__children["CowPathFilter"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["CowOrientation"] = GafferScene.Orientation( "CowOrientation" )
parent.addChild( __children["CowOrientation"] )
__children["CowOrientation"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Settings"] = Gaffer.Node( "Settings" )
parent.addChild( __children["Settings"] )
__children["Settings"]["user"].addChild( Gaffer.FloatPlug( "planetRadius", defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Settings"]["user"].addChild( Gaffer.FloatPlug( "robotDensity", defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Settings"]["user"].addChild( Gaffer.FloatPlug( "herdRadius", defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Settings"]["user"].addChild( Gaffer.FloatPlug( "cowDensity", defaultValue = 0.0, flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Settings"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Backdrop"] = Gaffer.Backdrop( "Backdrop" )
parent.addChild( __children["Backdrop"] )
__children["Backdrop"].addChild( Gaffer.V2fPlug( "__uiPosition", defaultValue = imath.V2f( 0, 0 ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
__children["Backdrop"].addChild( Gaffer.Box2fPlug( "__uiBound", defaultValue = imath.Box2f( imath.V2f( -10, -10 ), imath.V2f( 10, 10 ) ), flags = Gaffer.Plug.Flags.Default | Gaffer.Plug.Flags.Dynamic, ) )
parent["variables"]["imageCataloguePort"]["value"].setValue( 33243 )
Gaffer.Metadata.registerValue( parent["variables"]["imageCataloguePort"], 'readOnly', True )
Gaffer.Metadata.registerValue( parent["variables"]["projectName"]["name"], 'readOnly', True )
Gaffer.Metadata.registerValue( parent["variables"]["projectRootDirectory"]["name"], 'readOnly', True )
Gaffer.Metadata.registerValue( parent["variables"]["renderPass"]["name"], 'readOnly', True )
Gaffer.Metadata.registerValue( parent["variables"]["renderPass"]["value"], 'plugValueWidget:type', 'GafferSceneUI.RenderPassEditor._RenderPassPlugValueWidget' )
__children["Sphere"]["name"].setValue( 'planet' )
__children["Sphere"]["radius"].setInput( __children["Settings"]["user"]["planetRadius"] )
__children["Sphere"]["divisions"].setValue( imath.V2i( 100, 200 ) )
__children["Sphere"]["__uiPosition"].setValue( imath.V2f( 98.7575226, 8.72477531 ) )
Gaffer.Metadata.registerValue( __children["Scatter"], 'annotation:user:text', "We start by creating a sphere and scattering a small number of points on it. Later we'll instance robots onto these points." )
Gaffer.Metadata.registerValue( __children["Scatter"], 'annotation:user:color', imath.Color3f( 0.150000006, 0.25999999, 0.25999999 ) )
__children["Scatter"]["in"].setInput( __children["Sphere"]["out"] )
__children["Scatter"]["filter"].setInput( __children["PlanetPathFilter"]["out"] )
__children["Scatter"]["destination"].setValue( '/' )
__children["Scatter"]["name"].setValue( 'robots' )
__children["Scatter"]["density"].setInput( __children["Settings"]["user"]["robotDensity"] )
__children["Scatter"]["primitiveVariables"].setValue( 'N' )
__children["Scatter"]["__uiPosition"].setValue( imath.V2f( 98.7575226, 0.560712814 ) )
__children["PlanetPathFilter"]["paths"].setValue( IECore.StringVectorData( [ 'planet' ] ) )
__children["PlanetPathFilter"]["__uiPosition"].setValue( imath.V2f( 114.063698, 8.81326294 ) )
Gaffer.Metadata.registerValue( __children["RobotInstancer"], 'annotation:user:text', "Now we just use standard instancing setup to copy robots onto the points, using an Orientation node to orient them according to the sphere's normals." )
Gaffer.Metadata.registerValue( __children["RobotInstancer"], 'annotation:user:color', imath.Color3f( 0.150000006, 0.25999999, 0.25999999 ) )
__children["RobotInstancer"]["in"].setInput( __children["RobotOrientation"]["out"] )
__children["RobotInstancer"]["filter"].setInput( __children["RobotPathFilter"]["out"] )
__children["RobotInstancer"]["prototypes"].setInput( __children["RobotSceneReader"]["out"] )
__children["RobotInstancer"]["prototypeIndex"].setValue( 'prototypeIndex' )
__children["RobotInstancer"]["omitDuplicateIds"].setValue( False )
__children["RobotInstancer"]["orientation"].setValue( 'orientation' )
__children["RobotInstancer"]["scale"].setValue( 'scale' )
__children["RobotInstancer"]["inactiveIds"].setValue( 'inactiveIds invisibleIds' )
__children["RobotInstancer"]["attributePrefix"].setValue( 'user:' )
__children["RobotInstancer"]["__capsuleScene"]["bound"].setInput( __children["RobotInstancer"]["out"]["bound"] )
__children["RobotInstancer"]["__capsuleScene"]["transform"].setInput( __children["RobotInstancer"]["out"]["transform"] )
__children["RobotInstancer"]["__capsuleScene"]["attributes"].setInput( __children["RobotInstancer"]["out"]["attributes"] )
__children["RobotInstancer"]["__capsuleScene"]["globals"].setInput( __children["RobotInstancer"]["out"]["globals"] )
__children["RobotInstancer"]["__capsuleScene"]["setNames"].setInput( __children["RobotInstancer"]["out"]["setNames"] )
__children["RobotInstancer"]["__uiPosition"].setValue( imath.V2f( 100.257523, -127.818855 ) )
__children["RobotSceneReader"]["fileName"].setValue( '${GAFFER_ROOT}/resources/gafferBot/caches/gafferBot.scc' )
__children["RobotSceneReader"]["transform"]["scale"]["x"].setValue( 0.10000000149011612 )
__children["RobotSceneReader"]["transform"]["scale"]["y"].setInput( __children["RobotSceneReader"]["transform"]["scale"]["x"] )
__children["RobotSceneReader"]["transform"]["scale"]["z"].setInput( __children["RobotSceneReader"]["transform"]["scale"]["x"] )
__children["RobotSceneReader"]["__uiPosition"].setValue( imath.V2f( 151.942673, -92.6768875 ) )
__children["RobotOrientation"]["in"].setInput( __children["CowScatter"]["out"] )
__children["RobotOrientation"]["filter"].setInput( __children["RobotPathFilter"]["out"] )
__children["RobotOrientation"]["inMode"].setValue( 3 )
__children["RobotOrientation"]["inYAxis"].setValue( 'N' )
__children["RobotOrientation"]["randomEnabled"].setValue( True )
__children["RobotOrientation"]["randomTwist"].setValue( 180.0 )
__children["RobotOrientation"]["__uiPosition"].setValue( imath.V2f( 98.7575226, -119.654793 ) )
__children["RobotPathFilter"]["paths"].setValue( IECore.StringVectorData( [ '/robots' ] ) )
__children["RobotPathFilter"]["__uiPosition"].setValue( imath.V2f( 118.875374, -115.220436 ) )
Gaffer.Metadata.registerValue( __children["OSLObject"], 'annotation:user:text', 'Now we use the OSLObject node to generate two new per-vertex primitive variables on the sphere. We do this by adding the robot points as source geometry for the OSLObject node, and querying it using the pointcloud functions in OSL.\n\nThe source geometry is specified using the Source Locations tab for the OSLObject node in the NodeEditor. The work of querying it is performed using the OSLCode node on the left.' )
Gaffer.Metadata.registerValue( __children["OSLObject"], 'annotation:user:color', imath.Color3f( 0.150000006, 0.25999999, 0.25999999 ) )
__children["OSLObject"]["in"].setInput( __children["Scatter"]["out"] )
__children["OSLObject"]["filter"].setInput( __children["PlanetPathFilter"]["out"] )
__children["OSLObject"]["source"].setInput( __children["Scatter"]["out"] )
__children["OSLObject"]["sourceLocations"][0]["name"].setValue( 'robots' )
__children["OSLObject"]["sourceLocations"][0]["enabled"].setValue( True )
__children["OSLObject"]["sourceLocations"][0]["location"].setValue( '/robots' )
__children["OSLObject"]["sourceLocations"][0]["pointCloud"].setValue( True )
__children["OSLObject"]["sourceLocations"][0]["transform"].setValue( True )
__children["OSLObject"]["primitiveVariables"]["primitiveVariable"]["name"].setValue( 'cowDensity' )
__children["OSLObject"]["primitiveVariables"]["primitiveVariable"]["value"].setInput( __children["OSLCode"]["out"]["cowDensity"] )
__children["OSLObject"]["primitiveVariables"]["primitiveVariable1"]["name"].setValue( 'cowFacingDirection' )
__children["OSLObject"]["primitiveVariables"]["primitiveVariable1"]["value"].setInput( __children["OSLCode"]["out"]["cowFacingDirection"] )
__children["OSLObject"]["__uiPosition"].setValue( imath.V2f( 98.7575226, -45.1198578 ) )
__children["OSLCode"]["parameters"]["searchRadius"].setInput( __children["Settings"]["user"]["herdRadius"] )
__children["OSLCode"]["code"].setValue( '// The OSLObject node has been set up to provide us with access to the geometry from\n// the `/robots` location as a point cloud called "robots". We can query this using\n// OSL\'s standard `pointcloud_search()` and `pointcloud_get()` functions.\n\nint maxPoints = 1;\nint indices[1];\n// Workaround for OSL bug. We must assign a varying value to convince OSL that the\n// output from `pointcloud_search()` will be varying.\nindices[0] = int( P[0] );\n\n// `pointcloud_search()` finds the nearest points in the point cloud, returning the\n// results in arrays. In this case we only want to find the single closest point, so\n// we pass an array of length 1. If the search succeeds, the array will contain the\n// index of the closest point.\nif( pointcloud_search( "robots", P, searchRadius, maxPoints, "index", indices ) )\n{\n   // We can query the value of any vertex primitive variable for the point using\n   // the `pointcloud_get()` function. Here we\'re just querying "P" - it\'s position in\n   // space.\n\tpoint robotPoints[1];\n\tpointcloud_get( "robots", indices, 1, "P", robotPoints );\n\t// We can now calculate a density value we\'ll later use to scatter cows. This value\n\t// falls off radially from the closest point.\n\tcowDensity = clamp( 1 - distance( P, robotPoints[0] ) / searchRadius, 0, 1 );\n\t// We also calculate a vector pointing towards the closest point, which will later\n\t// be used to orient the cows.\n\tcowFacingDirection = normalize( robotPoints[0] - P );\n}\nelse\n{\n\tcowDensity = 0;\n\tcowFacingDirection = 0;\n}' )
__children["OSLCode"]["__uiPosition"].setValue( imath.V2f( 79.2276917, -44.5198555 ) )
Gaffer.Metadata.registerValue( __children["CowScatter"], 'annotation:user:text', 'Now we can scatter a second set of points, controlled by the density field we just created. We also transfer the `N` and `cowFacingDirection` primitive variables from the sphere onto the scattered points, for use downstream.' )
Gaffer.Metadata.registerValue( __children["CowScatter"], 'annotation:user:color', imath.Color3f( 0.150000006, 0.25999999, 0.25999999 ) )
__children["CowScatter"]["in"].setInput( __children["OSLObject"]["out"] )
__children["CowScatter"]["filter"].setInput( __children["PlanetPathFilter"]["out"] )
__children["CowScatter"]["destination"].setValue( '/' )
__children["CowScatter"]["name"].setValue( 'cows' )
__children["CowScatter"]["density"].setInput( __children["Settings"]["user"]["cowDensity"] )
__children["CowScatter"]["densityPrimitiveVariable"].setValue( 'cowDensity' )
__children["CowScatter"]["primitiveVariables"].setValue( 'N cowFacingDirection' )
__children["CowScatter"]["__uiPosition"].setValue( imath.V2f( 98.7575226, -85.0986633 ) )
__children["CowSceneReader"]["fileName"].setValue( '${GAFFER_ROOT}/resources/cow/cow.scc' )
__children["CowSceneReader"]["transform"]["scale"]["x"].setValue( 0.019999999552965164 )
__children["CowSceneReader"]["transform"]["scale"]["y"].setInput( __children["CowSceneReader"]["transform"]["scale"]["x"] )
__children["CowSceneReader"]["transform"]["scale"]["z"].setInput( __children["CowSceneReader"]["transform"]["scale"]["x"] )
__children["CowSceneReader"]["__uiPosition"].setValue( imath.V2f( 166.428329, -92.7167358 ) )
__children["CowInstancer"]["in"].setInput( __children["CowOrientation"]["out"] )
__children["CowInstancer"]["filter"].setInput( __children["CowPathFilter"]["out"] )
__children["CowInstancer"]["prototypes"].setInput( __children["CowSceneReader"]["out"] )
__children["CowInstancer"]["prototypeIndex"].setValue( 'prototypeIndex' )
__children["CowInstancer"]["omitDuplicateIds"].setValue( False )
__children["CowInstancer"]["orientation"].setValue( 'orientation' )
__children["CowInstancer"]["scale"].setValue( 'scale' )
__children["CowInstancer"]["inactiveIds"].setValue( 'inactiveIds invisibleIds' )
__children["CowInstancer"]["attributePrefix"].setValue( 'user:' )
__children["CowInstancer"]["__capsuleScene"]["bound"].setInput( __children["CowInstancer"]["out"]["bound"] )
__children["CowInstancer"]["__capsuleScene"]["transform"].setInput( __children["CowInstancer"]["out"]["transform"] )
__children["CowInstancer"]["__capsuleScene"]["attributes"].setInput( __children["CowInstancer"]["out"]["attributes"] )
__children["CowInstancer"]["__capsuleScene"]["globals"].setInput( __children["CowInstancer"]["out"]["globals"] )
__children["CowInstancer"]["__capsuleScene"]["setNames"].setInput( __children["CowInstancer"]["out"]["setNames"] )
__children["CowInstancer"]["__uiPosition"].setValue( imath.V2f( 101.757523, -158.152832 ) )
__children["CowPathFilter"]["paths"].setValue( IECore.StringVectorData( [ '/cows' ] ) )
__children["CowPathFilter"]["__uiPosition"].setValue( imath.V2f( 128.955368, -139.583176 ) )
Gaffer.Metadata.registerValue( __children["CowOrientation"], 'annotation:user:text', 'Likewise for copying the cows, except this time we are also using the `cowFacingDirection` in the Orientation node, to create our cyclone effect.' )
Gaffer.Metadata.registerValue( __children["CowOrientation"], 'annotation:user:color', imath.Color3f( 0.150000006, 0.25999999, 0.25999999 ) )
__children["CowOrientation"]["in"].setInput( __children["RobotInstancer"]["out"] )
__children["CowOrientation"]["filter"].setInput( __children["CowPathFilter"]["out"] )
__children["CowOrientation"]["inMode"].setValue( 3 )
__children["CowOrientation"]["inXAxis"].setValue( 'cowFacingDirection' )
__children["CowOrientation"]["inYAxis"].setValue( 'N' )
__children["CowOrientation"]["__uiPosition"].setValue( imath.V2f( 100.257523, -148.178284 ) )
__children["Settings"]["user"]["planetRadius"].setValue( 10.0 )
Gaffer.Metadata.registerValue( __children["Settings"]["user"]["planetRadius"], 'nodule:type', '' )
__children["Settings"]["user"]["robotDensity"].setValue( 0.05000000074505806 )
Gaffer.Metadata.registerValue( __children["Settings"]["user"]["robotDensity"], 'nodule:type', '' )
__children["Settings"]["user"]["herdRadius"].setValue( 2.5 )
Gaffer.Metadata.registerValue( __children["Settings"]["user"]["herdRadius"], 'nodule:type', '' )
__children["Settings"]["user"]["cowDensity"].setValue( 20.0 )
Gaffer.Metadata.registerValue( __children["Settings"]["user"]["cowDensity"], 'nodule:type', '' )
__children["Settings"]["__uiPosition"].setValue( imath.V2f( 59.2042923, 10.2099266 ) )
__children["Backdrop"]["title"].setValue( 'OSL PointCloud Example' )
__children["Backdrop"]["scale"].setValue( 2.0 )
__children["Backdrop"]["description"].setValue( "This example demonstrates how OSL's `pointcloud_search()` and `pointcloud_get()` functions can be used to access arbitrary geometry from the Gaffer scene. We'll be creating two point instancers, the first generating a small number of robots, and the second generating a larger number of cows. We'll use the OSL point cloud functions to position and orient the cows relative to the robots, so that they appear to be herding around them. Like a reindeer cyclone, but more bovine." )
__children["Backdrop"]["__uiPosition"].setValue( imath.V2f( 58.9869232, 45.3869286 ) )
__children["Backdrop"]["__uiBound"].setValue( imath.Box2f( imath.V2f( -10, -29.6144104 ), imath.V2f( 125.142929, 7.33914948 ) ) )


del __children
